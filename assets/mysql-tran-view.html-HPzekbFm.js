import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as r,c as p,a as s,d as a,b as l,f as n}from"./app-bYae3XOa.js";const c="/assets/1692860804-13ccf945137d839c6e6c29609c6f735e-Pf_o6QNR.png",o="/assets/1692860804-bbd001cd532c75ea98340c39f2ee3bb2-HOy1yCgG.png",d="/assets/1692860804-4c6c853b64636195a068b06f52765fec-WyCe2fCv.png",u="/assets/1692860804-63a763e795ba8fe47d71f61cccd19186-J4iM0zG3.png",b={},m=n('<h1 id="mysql8查看大事务" tabindex="-1"><a class="header-anchor" href="#mysql8查看大事务" aria-hidden="true">#</a> mysql8查看大事务</h1><h3 id="文章目录" tabindex="-1"><a class="header-anchor" href="#文章目录" aria-hidden="true">#</a> 文章目录</h3><ul><li><ul><li><a href="#1_1">1、查看大事务的原因</a></li><li><a href="#2_5">2、构建测试数据</a></li><li><a href="#3_22">3、模拟大事务场景</a></li><li><a href="#4mysql_43">4、查询mysql的事务</a></li><li><a href="#5_59">5、查询大事务的详情</a></li></ul></li></ul><h2 id="_1、查看大事务的原因" tabindex="-1"><a class="header-anchor" href="#_1、查看大事务的原因" aria-hidden="true">#</a> 1、查看大事务的原因</h2><p>大事务的特点是执行时间长，长期占有锁不释放，导致其他想操作同一行数据的线程阻塞，如果客户端设置了超时时间，超时后，客户端进行重试，又会申请一个mysql线程，然后再阻塞，最终会造成整个mysql库的线程枯竭，整个mysql库不可用，危害极大。<br> 所以，对于开发人员来说，非常有必要知道如何查看长事务，如何终止掉大事务。</p><h2 id="_2、构建测试数据" tabindex="-1"><a class="header-anchor" href="#_2、构建测试数据" aria-hidden="true">#</a> 2、构建测试数据</h2>',6),v={href:"https://so.csdn.net/so/search?q=DDL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},h=n('<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>CREATE TABLE <span class="token variable"><span class="token variable">`</span>user_read<span class="token variable">`</span></span>  <span class="token punctuation">(</span>\n  <span class="token variable"><span class="token variable">`</span>userId<span class="token variable">`</span></span> int NOT NULL,\n  <span class="token variable"><span class="token variable">`</span>userName<span class="token variable">`</span></span> varchar<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  PRIMARY KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>userId<span class="token variable">`</span></span><span class="token punctuation">)</span> USING BTREE\n<span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> InnoDB CHARACTER SET <span class="token operator">=</span> utf8mb4 COLLATE <span class="token operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="token operator">=</span> Dynamic<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再搞两条测试数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>INSERT INTO <span class="token variable"><span class="token variable">`</span>user<span class="token variable">`</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">`</span>user_read<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>userId<span class="token variable">`</span></span>, <span class="token variable"><span class="token variable">`</span>userName<span class="token variable">`</span></span><span class="token punctuation">)</span> VALUES <span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">&#39;test1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nINSERT INTO <span class="token variable"><span class="token variable">`</span>user<span class="token variable">`</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">`</span>user_read<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>userId<span class="token variable">`</span></span>, <span class="token variable"><span class="token variable">`</span>userName<span class="token variable">`</span></span><span class="token punctuation">)</span> VALUES <span class="token punctuation">(</span><span class="token number">2</span>, <span class="token string">&#39;test2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、模拟大事务场景" tabindex="-1"><a class="header-anchor" href="#_3、模拟大事务场景" aria-hidden="true">#</a> 3、模拟大事务场景</h2>',4),k=s("br",null,null,-1),_={href:"https://so.csdn.net/so/search?q=sql%E4%BF%AE%E6%94%B9&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},g=n(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#单位是秒,默认值是50秒</span>
<span class="token builtin class-name">set</span> global <span class="token assign-left variable">innodb_lock_wait_timeout</span><span class="token operator">=</span><span class="token number">5000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2)、开一个会话A，执行以下sql，模拟大事务<br> 我们手动构建一个加了排他锁的查询语句，只开启事务，不提交语句</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BEGIN<span class="token punctuation">;</span>
<span class="token keyword">select</span> * from user_read where <span class="token assign-left variable">userId</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> update<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为加了排他锁，执行完语句后，不提交事务，所以这就模拟了一个大事务的请求。<br> 3)、再开一个会话B，执行以下sql，模拟并发的请求</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>UPDATE user_read SET userName <span class="token operator">=</span> <span class="token string">&#39;test3&#39;</span> WHERE userId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时，因为行锁未释放，所以这条语句会阻塞住。这条语句就是模拟：在大事务存在的情况下，其他请求是不能操作同一行数据的。这样做，明显会影响数据库的并发性能。</p><h2 id="_4、查询mysql的事务" tabindex="-1"><a class="header-anchor" href="#_4、查询mysql的事务" aria-hidden="true">#</a> 4、查询mysql的事务</h2><p>1)、首先查看一下目前数据库中存在哪些事务</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SELECT * FROM information_schema.INNODB_TRX
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果如下图：<br><img src="`+c+`" alt="查看mysql中有哪些正在执行的事务" loading="lazy"><br> 2)、解读一下这两条记录<br> 可以看到目前库中有2个事务，事务id分别是：4220、4219。<br> 4219事务的执行状态是RUNNING、4220事务的执行状态是LOCK_WAIT。<br> RUNNING的意思是：当前事务正在执行。也就是我们在会话A中手动构建的那个大事务。虽然sql已经执行完，但是我们没有提交事务，所以INNODB_TRX表中就还能查到这个事务。但是因为sql语句已经执行完了，所以trx_query字段就没有信息了。<br> LOCK_WAIT的意思是：当前事务在等待锁，也就是我们在会话B中手动构建的update语句。因为这个事务还在等待锁，所以update语句并没有执行，所以trx_query字段能查询到当前待执行的sql语句。</p><p>3)、阶段性的排查结论<br> 通过以上排查，我们已经知道了目前数据库中存在正在执行的大事务，并且还知道已经出现了锁等待的情况。此刻，我们迫切想要知道的是这个大事务的sql是啥，能不能kill掉。但是因为大事务已经执行了sql语句，所以trx_query中没有了sql信息。所以我们要通过mysql的其他表查询这个大事务的详情，尤其是大事务的sql语句，进而知道是在做什么业务。</p><h2 id="_5、查询大事务的详情" tabindex="-1"><a class="header-anchor" href="#_5、查询大事务的详情" aria-hidden="true">#</a> 5、查询大事务的详情</h2><p>1)、查看哪些事务被阻塞了，被谁阻塞了</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> * from sys.innodb_lock_waits<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果<br><img src="`+o+`" alt="查看大事务的pid" loading="lazy"><br> 可以看到有一条UPDATE语句被阻塞了，阻塞者的id是22，这个id是22的事务就是我们排查的目标。接下来就是根据这个22继续查找详细信息。</p><p>2)、查询执行大事务的mysql线程id</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> thread_id,processlist_id from performance_schema.threads where <span class="token assign-left variable">processlist_id</span><span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：<br><img src="`+d+`" alt="查询执行大事务的线程id" loading="lazy"><br> 得到了执行大事务的线程id，接下来用这个线程id查询大事务对应的sql。<br> 3)、查询大事务的sql信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> thread_id,sql_text from performance_schema.events_statements_history where <span class="token assign-left variable">thread_id</span><span class="token operator">=</span><span class="token number">62</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果:<br><img src="`+u+`" alt="在这里插入图片描述" loading="lazy"><br> 至此，我们就得到了大事务的sql语句，接下来，可以根据sql语句对应一下业务模块，进而得出这个大事务能不能kill。如果确定可以kill，我们可以使用以下语句kill掉这个大事务</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">kill</span> <span class="token number">22</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：这个语句要在mysql的sql窗口执行，不是在linux服务器中执行。</p><p>参考：<br> https://www.51cto.com/article/743732.html</p>`,23);function f(q,y){const e=i("ExternalLinkIcon");return r(),p("div",null,[m,s("p",null,[a("很简单，就搞一张表，一个主键，一个业务字段。"),s("a",v,[a("DDL语句"),l(e)]),a("如下")]),h,s("p",null,[a("1)、修改事务超时时间"),k,a(" 默认的事务超时时间是50秒，不便于我们拍查问题，所以我们可以根据以下"),s("a",_,[a("sql修改"),l(e)]),a("事务的默认超时时间。注意：修改后，需要关闭当前的mysql连接，重新登录mysql才能生效。")]),g])}const x=t(b,[["render",f],["__file","mysql-tran-view.html.vue"]]);export{x as default};
